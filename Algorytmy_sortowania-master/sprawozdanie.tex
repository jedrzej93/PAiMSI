\documentclass{article}
\usepackage{polish}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\begin{document}
\title{Sprawozdanie ze złożoności obliczeniowej - PAiMSI}
\author{Patryk Jędrzejko}
\date{23.03.2014}
\maketitle
\begin{flushleft}
\indent
Celem ćwiczenia było napisanie programu, który będzie zawierał algorytmy sortowania, a następnie zbadanie złożoności obliczeniowej dla sortowania wczytanych danych z pliku. Program został napisany na podstawie wcześniejszej klasy Kolejka. Jest to klasa kolejki jako tablica.
Kolejno algorytmy sortowały ilość elementów
\\n = 10, 100, 1000, 10000,100000.\\
\indent
\\Wybrane algorytmy sortowania:
\item \textbf{QuickSort} - czyli szybkiego sortowania,
\item \textbf{MergeSort} - sortowanie przez scalanie,
\item \textbf{HeapSort} - sortowanie kopcem.
\\
\indent
\\Pierwszy z nich algorytm QuickSort jest przykładem zastosowania techniki "dziel i zwyciężaj" i składa się z 3 faz: 1.najpierw wejściowy ciąg liczb jest dzielony na dwa podciągi, 2. następnie te dwa podciągi są sortowane rekurencyjnie, 3. posortowane podciągi scala się w jeden posortowany ciąg.\\
\indent
\\Algorytm MergeSort jest jednym z prostrzych przykładów zastosowania wyżej wymienionej techniki "dziel i zwyciężaj", to znaczy: 1. dzieli ciąg na dwa ciągi o długości n/2, 2. sortuje te dwa ciągi przy użyciu sortowania przez scalanie, 3. posortowane ciągi długości n/2 scala w posortowany ciąg długości n.\\
\indent
\\Trzeci algorytm sortowania HeapSort, czyli sortowanie przez kopcowanie opiera się na stworzeniu kopca, a następnie na rozbiorze utworzonego kopca, w wyniku czego otrzymujemy posortowany ciąg.\\
\indent
\\Analizując wyniki obliczeń w arkuszu kalkulacyjnym otrzymanych czasów sortowania użytych algorytmów możemy wyciągnąć wnioski takie, że:\\
\\
\item Klasa złożoności obliczeniowej dla algorytmu QuickSort dla elementów posortowanych malejąco oraz posortowanych wynosi O(n^2)
\\czyli dla najgorszego przypadku (złożoność pesymistyczna), zaś dla najlepszego przypadku klasa złożoności przyjmuje wartość O(nlogn) dla elementów losowych (złożoność optymistyczna oraz typowa). Przez co możemy określić iż sortowanie szybkie nie jest sortowaniem stabilnym. \\
\\
\item Dla algorytmu MergeSort oraz HeapSort klasa złożoności wynosi O(n logn) dla elementów losowych, posortowanych jak i posortowanych malejąco.
\indent
\\Porównując czasy wykonania sortowania dla różnych ilości n elementów do posortowania widzimy, że dla małej liczby elementów tj. n = 10, to są różnice nieznaczne, zaś dla n = 100000 elementów możemy już stwierdzić różnicę czasową w wykonaniu sortowania dla elementów losowych.\\
\indent
\\Następnie możemy odczytać z tabeli, że dla sortowania przez scalanie dla elementów losowych algorytm jest najwolniejszy. Dla elementów posortowanych malejąco algorytm wykonuje sortowanie najszybciej.\\
\indent
\\Zaś dla sortowania szybkiego widzimy znaczące zmiany dla elementów posortowanych i malejących, co może wynikać z nieprawidłowego wykonania algorytmu sortowania bądź też niestabilności sortowania szybkiego. Znaczące zmiany widzimy już dla n = 1000. Dlatego QuickSort jest najszybszy dla elementów losowych.\\
\indent
\\Dla sortowania przez kopcowanie mamy podobnie jak z SortMerge. Widzimy, że dla elementów posortowanych sortowanie wykonuje się najszybciej, zaś dla malejących najwolniej.\\  
\indent
\\Możemy zatem stwierdzić, iż algorytm szybkiego sortowania jest najszybszy, ale tylko dla elementów losowych. Zaś najwolniejszym z nich jest algorytm kopcowania. Co za tym idzie algorytm QuickSort jest efektywniejszy od pozostałych algorytmów sortowania.\\
\indent
\textbf{Tabela wyników oraz wykresy na stronie 3 oraz 4.}
\\
\begin{figure}[H]
\includegraphics[width=\textwidth]{sort_czas1.pdf}
\label{fig:sort_czas1.pdf}
\end{figure}

\begin{figure}[H]
\includegraphics[width=\textwidth]{sort_czas2.pdf}
\label{fig:sort_czas2.pdf}
\end{figure}
\end{flushleft}
\end{document}