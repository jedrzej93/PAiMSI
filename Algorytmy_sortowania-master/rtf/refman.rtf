{\rtf1\ansi\ansicpg1250\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset238\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset238\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset238\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Algorytmy sortowania  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.1 \par
}}Algorytmy sortowania}
{\comment Wygenerowano przezDoxgyen. }
{\creatim \yr2014\mo3\dy24\hr13\min1\sec48}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.1\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Spis tre\'9Cci\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Algorytmy sortowania\par \pard\plain 
{\tc \v Algorytmy sortowania}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Autor:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Patryk Jedrzejko \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Data:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 23.03.2014 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Wersja:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.1\par
}Program wykonujacy algorytmy sortowania: \par QuickSort - sortowania szybkiego, \par MergeSort - sortowanie przez scalanie, \par HeapSort - sortowanie przez kopcowanie. \par Program zostal napisany na bazie klasy {\b Kolejka} jako tablica. \par Funkcje poszczegolnych algorytmow zostaly dodane to tej wlasnie klasy. Dane dla tej klasy wczytywany sa z plikow stos.txt, stos100.txt \par stos1000.txt oraz stos10000.txt zawierajace kolejno, n = 10, 100, 1000, 10000 elementow wylosowanych. \par Program rowniez liczy czas poprzez klase {\b Benchmark} szybkosci wykonania operacji sortowania dla poszczegolnych algorytmow. \par Poprzez menu uzytkownik moze wybrac jakim algorytmem chce posortowac dany zbior elementow. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indeks klas\par \pard\plain 
{\tc \v Indeks klas}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista klas\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Tutaj znajduj\'B9 si\'EA klasy, struktury, unie i interfejsy wraz z ich kr\'F3tkimi opisami:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Benchmark} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Kolejka} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Dokumentacja klas{\tc \v Dokumentacja klas}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Dokumentacja klasy Benchmark\par \pard\plain 
{\tc\tcl2 \v Benchmark}
{\xe \v Benchmark}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Metody publiczne\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Benchmark} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor klasy {\b Benchmark}. Konstruktor jest funkcja bezparametryczna. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wykonaj_Sortowanie} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wykonujaca algorytmy sortowania. Funkcja wykonuje wczytanie danych z plikow stos.txt, stos100.txt, stos1000.txt, stos10000.txt. ktore zawieraja wylosowane liczby z przedzialu odpowiedniego do liczby elementow Uzytkownik poprzez menu moze wybrac dla jakiego zbioru elementow ma byc wykonane sortowanie i dla jakiego algorytmu, tj. sortowanie szybkie - QuickSort, sortowanie przez kopcowanie - HeapSort oraz sortowanie przez scalanie - SortMerge. Po wyborze przez uzytkownika opcji, zostaje wlaczany zegar, jest wykonywany algorytm sortowania, a na koncu zegar zostaje zatrzymany i wyswietlony calkowity czas operacji wykonania sortowania. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Start} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja startujaca zegar. Funkcja odpala zegar, ktory liczy czas zapelnienia stosu czy tez kolejki danymi wczytanymi z pliku. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Stop} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja zatrzymujaca zegar. Funkcja zatrzymuje zegar, ktory liczy czas zapelnienia stosu czy tez kolejki danymi wczytanymi z pliku. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Czas_Operacji} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja zawieracaja czas operacji zegaru. Funkcja zwraca nam czas calkowity wykonanej operacji w ms. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atrybuty prywatne\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
timeval {\b czas1}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienne typu timeval, zmienne przyjmujace wartosci czasu start i stop. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
timeval {\b czas2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b CzasOperacji}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu double, zawiera wartosc czasu operacji. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Opis szczeg\'F3\'B3owy\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasa {\b Benchmark} w owej klasie definiujemy funkcje odpowiedzialne za wykonanie algorytmu benchmarku, ktory zwraca nam czas w ms jaki uplynal podczas wykonywania operacji. \par
}{
Definicja w linii 22 pliku benchmark.hh.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja konstruktora i destruktora\par
\pard\plain 
{\xe \v Benchmark\:Benchmark}
{\xe \v Benchmark\:Benchmark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Benchmark::Benchmark} (){\f2  [inline]}}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 38 pliku benchmark.hh.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja funkcji sk\'B3adowych\par
\pard\plain 
{\xe \v Czas_Operacji\:Benchmark}
{\xe \v Benchmark\:Czas_Operacji}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b Benchmark::Czas_Operacji} ()}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 112 pliku benchmark.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        CzasOperacji = (czas2.tv_sec - czas1.tv_sec)*1000.0;\par
        CzasOperacji += (czas2.tv_usec - czas1.tv_usec) / 1000.0;\par
        cout << CzasOperacji << "ms." << endl;\par
\par
        return CzasOperacji;\par
\}}
}
{\xe \v Start\:Benchmark}
{\xe \v Benchmark\:Start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Benchmark::Start} ()}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 100 pliku benchmark.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        //cout << "Zegar wlaczony!" << endl;\par
        gettimeofday(&czas1, NULL);\par
\}\par
}
}
{\xe \v Stop\:Benchmark}
{\xe \v Benchmark\:Stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Benchmark::Stop} ()}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 106 pliku benchmark.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        //cout << "Zegar wylaczony!" << endl;\par
        gettimeofday(&czas2, NULL);\par
\}\par
}
}
{\xe \v Wykonaj_Sortowanie\:Benchmark}
{\xe \v Benchmark\:Wykonaj_Sortowanie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Benchmark::Wykonaj_Sortowanie} ()}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 19 pliku benchmark.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        Kolejka K;\par
        \par
        int wybor;\par
\par
        cout << "----MENU BENCHMARK----" << endl;\par
        cout << "1 - SORTOWANIE PRZEZ SCALANIE 10 ELEMENTOW" << endl;\par
        cout << "2 - SORTOWANIE PRZEZ SCALANIE 100 ELEMENTOW" << endl;\par
        cout << "3 - SORTOWANIE PRZEZ SCALANIE 1000 ELEMENTOW " << endl;\par
        cout << "4 - SORTOWANIE PRZEZ SCALANIE 10000 ELEMENTOW " << endl;\par
        cout << "5 - SORTOWANIE SZYBKIE 10 ELEMENTOW " << endl;\par
        cout << "6 - SORTOWANIE SZYBKIE 100 ELEMENTOW " << endl;\par
        cout << "7 - SORTOWANIE SZYBKIE 1000 ELEMENTOW " << endl;\par
        cout << "8 - SORTOWANIE SZYBKIE 10000 ELEMENTOW " << endl;\par
        cout << "9 - SORTOWANIE KOPCEM 10 ELEMENTOW " << endl;\par
        cout << "10 - SORTOWANIE KOPCEM 100 ELEMENTOW " << endl;\par
        cout << "11 - SORTOWANIE KOPCEM 1000 ELEMENTOW " << endl;\par
        cout << "12 - SORTOWANIE KOPCEM 10000 ELEMENTOW " << endl;\par
        cout << "13 - ZAKONCZ PROGRAM " << endl;\par
        cout << " WYBIERZ OPCJE: ";\par
        cin >> wybor;\par
\par
        switch(wybor)\par
        \{\par
                case 1: \par
                        cout << "Sortowanie przez scalanie dla 10 elementow: ";\par
                        K.Wczytaj_Dane("stos.txt"); Start(); K.Sort_Merge(0,9); Stop(); Czas_Operacji();\par
                        break;\par
                case 2: \par
                        cout << "Sortowanie przez scalanie dla 100 elementow: ";\par
                        K.Wczytaj_Dane("stos100.txt"); Start(); K.Sort_Merge(0,99); Stop(); Czas_Operacji();                    \par
                        break;\par
                case 3:\par
                        cout << "Sortowanie przez scalanie dla 1000 elementow: ";\par
                        K.Wczytaj_Dane("stos1000.txt"); Start(); K.Sort_Merge(0,999); Stop(); Czas_Operacji();\par
                        break;\par
                case 4:\par
                        cout << "Sortowanie przez scalanie dla 10000 elementow: ";\par
                        K.Wczytaj_Dane("stos10000.txt"); Start(); K.Sort_Merge(0,9999); Stop(); Czas_Operacji();\par
                        break;\par
                case 5: \par
                        cout << "Sortowanie szybkie dla 10 elementow: ";\par
                        K.Wczytaj_Dane("stos.txt"); Start(); K.Quick_Sort(0,9); Stop(); Czas_Operacji();\par
                        break;\par
                case 6: \par
                        cout << "Sortowanie szybkie dla 100 elementow: ";\par
                        K.Wczytaj_Dane("stos100.txt"); Start(); K.Quick_Sort(0,99); Stop(); Czas_Operacji();\par
                        break;\par
                case 7: \par
                        cout << "Sortowanie szybkie dla 1000 elementow: ";\par
                        K.Wczytaj_Dane("stos1000.txt"); Start(); K.Quick_Sort(0,999); Stop(); Czas_Operacji();\par
                        break;\par
                case 8: \par
                        cout << "Sortowanie szybkie dla 10000 elementow: ";\par
                        K.Wczytaj_Dane("stos10000.txt"); Start(); K.Quick_Sort(0,9999); Stop(); Czas_Operacji();\par
                        break;  \par
                case 9: \par
                        cout << "Sortowanie kopcem dla 10 elementow: ";\par
                        K.Wczytaj_Dane("stos.txt"); Start(); K.Wykonaj_Heap_Sort(); Stop(); Czas_Operacji();\par
                        break;\par
                case 10: \par
                        cout << "Sortowanie kopcem dla 100 elementow: ";\par
                        K.Wczytaj_Dane("stos100.txt"); Start(); K.Wykonaj_Heap_Sort(); Stop(); Czas_Operacji();\par
                        break;  \par
                case 11: \par
                        cout << "Sortowanie kopcem dla 1000 elementow: ";\par
                        K.Wczytaj_Dane("stos1000.txt"); Start(); K.Wykonaj_Heap_Sort(); Stop(); Czas_Operacji();\par
                        break;  \par
                case 12: \par
                        cout << "Sortowanie kopcem dla 10000 elementow: ";\par
                        K.Wczytaj_Dane("stos10000.txt"); Start(); K.Wykonaj_Heap_Sort(); Stop(); Czas_Operacji();\par
                        break;                  \par
                case 13:\par
                                cout << "ZAKONCZONO PROGRAM " << endl;\par
                                break;\par
                default:\par
                                break;\par
        \}\par
\}\par
}
{
Oto graf wywo\'B3a\'F1 dla tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_benchmark_a4b7c72902d81ff3829f990b3b112b5e1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja atrybut\'F3w sk\'B3adowych\par
\pard\plain 
{\xe \v czas1\:Benchmark}
{\xe \v Benchmark\:czas1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
timeval {\b Benchmark::czas1}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 28 pliku benchmark.hh.}\par
}
{\xe \v czas2\:Benchmark}
{\xe \v Benchmark\:czas2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
timeval {\b Benchmark::czas2}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 28 pliku benchmark.hh.}\par
}
{\xe \v CzasOperacji\:Benchmark}
{\xe \v Benchmark\:CzasOperacji}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b Benchmark::CzasOperacji}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 32 pliku benchmark.hh.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Dokumentacja klasy Kolejka\par \pard\plain 
{\tc\tcl2 \v Kolejka}
{\xe \v Kolejka}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Metody publiczne\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Kolejka} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor klasy {\b Kolejka}. Konstruktor jest funkcja bezparametryczna, zerujaca wszystkie skladniki zawarte w private. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Kolejka} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destruktor klasy {\b Kolejka}. Destruktor zwalnia pamiec za pomoca usuniecia dynamicznej tablicy Tab i Tab_temp. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja isEmpty Zwraca nam czy w stosie zawarte sa jakies elementy badz tez brak. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} (int dodaj_elem)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja push. Deklaracja funkcji odpowiedzialnej za dodawanie elementu do kolejki. Uzytkownik podaje wartosc elementu jaki chce dodac do kolejki. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja pop. Deklaracja funkcji odpowiedzialna za usuwanie elementu z kolejki. Funkcja usuwa ostatni element znajdujacy sie w kolejce i zmiejsza jego rozmiar o jeden. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wczytaj_Dane} (string nazwa_pliku)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja Wczytaj dane. Funkcja wczytuje dane z pliku o zadanej nazwie pliku. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wyswietl_Dane} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wyswietlajaca dane. Funkcja odpowiedzalna za wyswietlenie kolejki. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Menu} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wyswietlajca menu klasy {\b Kolejka}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Quick_Sort} (int pocz_p, int koniec_p)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wykonujaca algorytm szybkiego sortowania. Funkcja zawierajaca dwie zmienne, ktore wskazuja na poczatek oraz koniec zbioru. Dzieki czemu sprawdzamy czy partycje utworzone poprzez funkcje Partition zawieraja wiecej niz jeden element. Jezeli tak, to wywolujemy rekurencyjnie algorytm sortowania szybkiego z wyznaczonymi granicami partycji. Po tym wywolaniu partycja jest posortowana rosnaco. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Partition} (int *{\b Tab}, int pocz_p, int koniec_p)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja tworzaca partycje do algorytmu szybkiego sortowania. Funkcja wykorzystuje dwa wskazniki na poczatku zbioru i,j. Zmienna i przeszukuje zbior utworzonej partycji mniejszej wartosci niz wartosc najwieksza tej partycji. A nastepnie gdy natrafi na mniejsza, to jest ta wartosc zamieniana poprzez zmienna j. Kolejno wskaznik j przesuwa sie na nastepna pozycje. Wskaznik j zapmamietuje pozycje na ktorej znajduje sie nastepny element, zatem na koncu zbioru wskaze pozycje zakonczenia partycji. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wyswietl_Dane_Quick_Sort} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wyswietlajaca posortowane dane za pomoca algorytmu QuickSort. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Sort_Merge} (int l_p, int l_k)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja sortowania przez scalanie. Algorytm wywolujemy z zadanymi wartosciami indeksow l_p oraz l_k ktore powinny objac caly zbior tablicy. Na poczatku algorytm dzieli poprzez zmienna polowa zbior na dwie polowki, a nastepnie sprawdzamy czy dana polowka zawiera wiecej niz jeden element. Jezeli tak to to rekurencyjnie sortujemy algorytmem przez scalanie. Po operacji sortowania dla dwoch polowek uporzadkowane zbiory scalamy je i zakanczamy algorytm. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wyswietl_Dane_Sort_Merge} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wyswietlajaca posortowane dane za pomoca algorytmu SortMerge. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Buduj_Kopiec} (int *{\b Tab})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja algorytmu sortowania przez kopcowanie. Funkcja budujaca kopiec, ktory uzywany jest to sortowanie przez kopcowanie. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Rozbierz_Kopiec} (int *{\b Tab})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja algorytmu sortowania przez kopcowanie. Funkcja rozbierajaca kopiec, dzieki czemu elementy, ktore budowaly kopiec zostaly rozebrany i w ten sposob sa posortowane. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wyswietl_Dane_Heap_Sort} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wyswietlajaca posortowane dane za pomoca algorytmu HeapSort. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Wykonaj_Heap_Sort} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funkcja wykonujaca algorytm HeapSort. Najpierw jest budowany kopiec, a nastepnie rozebrany. Dzieki temu mamy posortowane elementy. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atrybuty prywatne\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rozmiar_tab}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu int, przechowuje rozmiar kolejki. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wsk_pocz}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu int, wskazuje wartosc poczatkowa kolejki. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b licz_elem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu int, zmienna pomocnicza przy liczeniu ilosci elementow. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b k}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienne typu int, wykorzystywany do. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b j}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b Tab}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu int, tablica dynamiczna kolejki. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int * {\b Tab_temp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zmienna typu int, tablica dynamiczna pomocnicza kolejki. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Opis szczeg\'F3\'B3owy\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasa {\b Kolejka} zawiera dwie tablice dynamiczne, ktora jedna z nich zawiera dane dotyczace kolejki i na ktorej beda dokonywane operacje, a druga jako tablica tymczasowa do przechowywania danych. \par
}{
Definicja w linii 26 pliku kolejka_tablica.hh.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja konstruktora i destruktora\par
\pard\plain 
{\xe \v Kolejka\:Kolejka}
{\xe \v Kolejka\:Kolejka}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Kolejka::Kolejka} ()}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 10 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        wsk_pocz = licz_elem = rozmiar_tab = 0;\par
        Tab = 0;\par
        Tab_temp = 0;\par
\}\par
}
}
{\xe \v ~Kolejka\:Kolejka}
{\xe \v Kolejka\:~Kolejka}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Kolejka::~Kolejka} (){\f2  [inline]}}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 64 pliku kolejka_tablica.hh.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ delete [] Tab; rozmiar_tab = 0; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja funkcji sk\'B3adowych\par
\pard\plain 
{\xe \v Buduj_Kopiec\:Kolejka}
{\xe \v Kolejka\:Buduj_Kopiec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Buduj_Kopiec} (int * {\i Tab})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 207 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int temp;\par
\par
        for(int i = 2; i <= rozmiar_tab; i++)\par
        \{\par
                j = i;\par
                k = j / 2;\par
                temp = Tab[i];\par
                while((k > 0) && (Tab[k] < temp))\par
                \{\par
                        Tab[j] = Tab[k];\par
                        j = k;\par
                        k = j / 2;\par
                \}\par
                Tab[j] = temp;\par
        \}\par
\}\par
}
}
{\xe \v isEmpty\:Kolejka}
{\xe \v Kolejka\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b Kolejka::isEmpty} ()}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 17 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        if(rozmiar_tab == 0)\par
                return 1;\par
        else\par
                return 0;\par
\}\par
}
}
{\xe \v Menu\:Kolejka}
{\xe \v Kolejka\:Menu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Menu} ()}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 272 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        Kolejka K;\par
        K.Wczytaj_Dane("stos.txt");\par
        K.Wyswietl_Dane_Quick_Sort();\par
        K.Wyswietl_Dane_Sort_Merge();\par
        K.Wyswietl_Dane_Heap_Sort();\par
\}}
{
Oto graf wywo\'B3a\'F1 dla tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_adf3fa87d0693b7f11835e8a67d2efcc1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Partition\:Kolejka}
{\xe \v Kolejka\:Partition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::Partition} (int * {\i Tab}, int {\i pocz_p}, int {\i koniec_p})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 109 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int elem, temp, i, j;\par
\par
        elem = Tab[pocz_p];\par
        i = pocz_p;\par
        j = koniec_p;\par
        do\par
        \{\par
                do\par
                \{\par
                        i++;\par
                \}\par
        while(Tab[i] < elem);\par
                do\par
                \{\par
                        j--;\par
                \}\par
        while(Tab[j] > elem);\par
                if (i < j)\par
                \{\par
                        temp = Tab[i];\par
                        Tab[i] = Tab[j];\par
                        Tab[j] = temp;\par
                \}\par
        \}\par
        while(i < j);\par
        Tab[pocz_p] = Tab[j];\par
        Tab[j] = elem;\par
\par
        return j;\par
\}\par
}
}
{\xe \v pop\:Kolejka}
{\xe \v Kolejka\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::pop} (void )}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 25 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        if(rozmiar_tab != 0)\par
        \{\par
                Tab_temp = new int[rozmiar_tab];\par
                for(int i = 0; i < rozmiar_tab; i++)\par
                        Tab_temp[i] = Tab[i];\par
                delete Tab;\par
                --rozmiar_tab;\par
\par
                Tab = new int[rozmiar_tab];\par
                for(int i = 0; i < rozmiar_tab; i++)\par
                        Tab[i] = Tab_temp[i];\par
                delete [] Tab_temp;\par
        \}\par
        else \par
                cout << endl;\par
\}\par
}
}
{\xe \v push\:Kolejka}
{\xe \v Kolejka\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::push} (int {\i dodaj_elem})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametry:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dodaj_elem} \cell }{- parametr typu int, przechowuje wartosc zadana przez uzytkownika. \cell }
{\row }
}
}{
Definicja w linii 44 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        if( rozmiar_tab != 0)\par
        \{\par
                Tab_temp = new int[rozmiar_tab];\par
                for(int i = 0; i < rozmiar_tab; i++)\par
                \{\par
                        Tab_temp[i] = Tab[i];\par
                \}\par
                delete [] Tab;\par
\par
                ++rozmiar_tab;\par
                Tab = new int[rozmiar_tab];\par
                Tab[0] = dodaj_elem;\par
                \par
                int x = 1;\par
                for(int i = 0; i < (rozmiar_tab - 1); i++)\par
                \{\par
                        Tab[x] = Tab_temp[i];\par
                        x++;\par
                \}\par
                x = 0;\par
                delete [] Tab_temp;\par
        \} \par
        else\par
        \{\par
                ++rozmiar_tab;\par
                Tab = new int[1];\par
                Tab[0] = dodaj_elem;\par
        \}\par
\par
\}\par
}
}
{\xe \v Quick_Sort\:Kolejka}
{\xe \v Kolejka\:Quick_Sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Quick_Sort} (int {\i pocz_p}, int {\i koniec_p})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 142 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int wart_elem;\par
        if(pocz_p < koniec_p)\par
        \{\par
                wart_elem = Partition(Tab, pocz_p, koniec_p + 1);\par
                Quick_Sort(wart_elem + 1, koniec_p);\par
                Quick_Sort(pocz_p, wart_elem - 1);\par
        \}\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_a29d7138233171af5ac991e4ef4597eb4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Rozbierz_Kopiec\:Kolejka}
{\xe \v Kolejka\:Rozbierz_Kopiec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Rozbierz_Kopiec} (int * {\i Tab})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 226 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int m;\par
\par
        for(int i = rozmiar_tab; i > 1; i--)\par
        \{\par
                swap(Tab[1], Tab[i]);\par
                j = 1;\par
                k = 2;\par
                while( k < i)\par
                \{\par
                        if((k + 1 < i) && (Tab[k + 1] > Tab[k]))\par
                                m = k + 1;\par
                        else\par
                                m = k;\par
                        if(Tab[m] <= Tab[j])\par
                                break;\par
                        swap(Tab[j], Tab[m]);\par
                        j = m;\par
                        k = j + j;\par
                \}\par
        \}\par
\}\par
}
}
{\xe \v Sort_Merge\:Kolejka}
{\xe \v Kolejka\:Sort_Merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Sort_Merge} (int {\i l_p}, int {\i l_k})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 169 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int polowa, l1, l2, l;\par
\par
        polowa = (l_p + l_k + 1) / 2;\par
        if(polowa - l_p > 1)\par
                Sort_Merge(l_p, polowa - 1);\par
        if(l_k - polowa > 0)\par
                Sort_Merge(polowa, l_k);\par
        l1 = l_p;\par
        l2 = polowa;\par
        for(l = l_p; l <= l_k; l++)\par
        \{\par
                Tab_temp[l] = ((l1 == polowa) || ((l2 <= l_k) && (Tab[l1] > Tab[l2]))) ? Tab[l2++]: Tab[l1++];\par
        \}\par
        for(l = l_p; l <= l_k; l++)\par
        \{\par
                Tab[l] = Tab_temp[l];\par
        \}\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_a80ab27bb35ddb60d0c0614da14e46c3a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Wczytaj_Dane\:Kolejka}
{\xe \v Kolejka\:Wczytaj_Dane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wczytaj_Dane} (string {\i nazwa_pliku})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parametry:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nazwa_pliku} \cell }{- zmienna typu string zawierajaca dokladna nazwe pliku do wczytania. \cell }
{\row }
}
}{
Definicja w linii 91 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        int temp;\par
\par
        ifstream plik(nazwa_pliku.c_str());\par
\par
        if(!plik)\par
        \{\par
                cerr << "Nie mozna otworzyc pliku!" << endl;\par
                getchar();\par
        \}\par
        else\par
        \{\par
                while(plik >> temp)\par
                        push(temp);\par
        \}\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_a449374680f4f4cc633f067c4fb0fac3d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Wykonaj_Heap_Sort\:Kolejka}
{\xe \v Kolejka\:Wykonaj_Heap_Sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wykonaj_Heap_Sort} ()}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 250 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        Buduj_Kopiec(Tab);\par
        Rozbierz_Kopiec(Tab);\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_ad9a907fcc67803e1ff8a348ecde1aa5b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Wyswietl_Dane\:Kolejka}
{\xe \v Kolejka\:Wyswietl_Dane}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wyswietl_Dane} ()}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 77 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{       \par
        if(rozmiar_tab != 0)\par
        \{\par
                cout << "Zawartosc kolejki:  " << endl;\par
                for(int i = (rozmiar_tab - 1); i >= 0 ; i--)\par
                \{\par
                        cout << Tab[i] << endl;\par
                \}\par
        \} \par
        else\par
                cout << "Brak elementow! " << endl;\par
\}\par
}
}
{\xe \v Wyswietl_Dane_Heap_Sort\:Kolejka}
{\xe \v Kolejka\:Wyswietl_Dane_Heap_Sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wyswietl_Dane_Heap_Sort} ()}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 256 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        Wykonaj_Heap_Sort();\par
\par
        if(rozmiar_tab != 0)\par
        \{\par
                cout << "Zawartosc kolejki:  " << endl;\par
                for(int i = 0; i <= rozmiar_tab ; i++)\par
                \{\par
                        cout << Tab[i] << endl;\par
                \}\par
        \} \par
        else\par
                cout << "Brak elementow! " << endl;\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_aba08defbed8f23d0f7d17513dc296f57_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Wyswietl_Dane_Quick_Sort\:Kolejka}
{\xe \v Kolejka\:Wyswietl_Dane_Quick_Sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wyswietl_Dane_Quick_Sort} ()}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 153 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{       \par
        Quick_Sort(0,9);\par
\par
        if(rozmiar_tab != 0)\par
        \{\par
                cout << "Zawartosc kolejki:  " << endl;\par
                for(int i = 0; i < rozmiar_tab ; i++)\par
                \{\par
                        cout << Tab[i] << endl;\par
                \}\par
        \} \par
        else\par
                cout << "Brak elementow! " << endl;\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_a482fc74f6e5e3dd4760be59130a7eec5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Wyswietl_Dane_Sort_Merge\:Kolejka}
{\xe \v Kolejka\:Wyswietl_Dane_Sort_Merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b Kolejka::Wyswietl_Dane_Sort_Merge} ()}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 190 pliku kolejka_tablica.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{       \par
        Sort_Merge(0,9);\par
\par
        if(rozmiar_tab != 0)\par
        \{\par
                cout << "Zawartosc kolejki:  " << endl;\par
                for(int i = 0; i < rozmiar_tab ; i++)\par
                \{\par
                        cout << Tab[i] << endl;\par
                \}\par
        \} \par
        else\par
                cout << "Brak elementow! " << endl;\par
\}\par
}
{
Oto graf wywo\'B3ywa\'F1 tej funkcji:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_kolejka_ab074854cd1004b8a7c5a9413a141312e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentacja atrybut\'F3w sk\'B3adowych\par
\pard\plain 
{\xe \v j\:Kolejka}
{\xe \v Kolejka\:j}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::j}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 44 pliku kolejka_tablica.hh.}\par
}
{\xe \v k\:Kolejka}
{\xe \v Kolejka\:k}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::k}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 44 pliku kolejka_tablica.hh.}\par
}
{\xe \v licz_elem\:Kolejka}
{\xe \v Kolejka\:licz_elem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::licz_elem}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 40 pliku kolejka_tablica.hh.}\par
}
{\xe \v rozmiar_tab\:Kolejka}
{\xe \v Kolejka\:rozmiar_tab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::rozmiar_tab}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 32 pliku kolejka_tablica.hh.}\par
}
{\xe \v Tab\:Kolejka}
{\xe \v Kolejka\:Tab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int* {\b Kolejka::Tab}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 48 pliku kolejka_tablica.hh.}\par
}
{\xe \v Tab_temp\:Kolejka}
{\xe \v Kolejka\:Tab_temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int* {\b Kolejka::Tab_temp}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 52 pliku kolejka_tablica.hh.}\par
}
{\xe \v wsk_pocz\:Kolejka}
{\xe \v Kolejka\:wsk_pocz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Kolejka::wsk_pocz}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definicja w linii 36 pliku kolejka_tablica.hh.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Indeks\par 
\pard\plain 
{\tc \v Indeks}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}